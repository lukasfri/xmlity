<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The XMLity Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The XMLity Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-xmlity"><a class="header" href="#introduction-to-xmlity">Introduction to XMLity</a></h1>
<p>XMLity is a (de)serialization library for XML, inspired by <a href="https://serde.rs/">Serde</a> and improves upon XML (de)serialization libraries such as <a href="https://github.com/media-io/yaserde">yaserde</a> and <a href="https://github.com/tafia/quick-xml">quick-xml</a> by providing a more flexible API that is more powerful, utilising primairly a trial and error approach to parsing XML. This can inherently be a bit slower than other libraries, but it allows for more complex XML structures to be parsed.</p>
<p>Want to get started? <a href="./1_getting_started/README.html">Click here</a>.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Why does XMLity need to exist? Doesn't other XML-parsers/deserializers exist in Rust and why should I use/contribute to XMLity instead? To answer these questions, we've provided a feature chart below that</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>XMLity</th><th>Yaserde</th><th>quick-xml (serde)</th></tr></thead><tbody>
<tr><td>Trial and error deserialization</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td>Multiple reader/writer implementation support</td><td>Yes *</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>* While XMLity does have support for multiple readers/writers, the only current one that exists is one using quick-xml, even if others are supported due to the data-model being completely deconnected from any other library. This should change in the near future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-get-help"><a class="header" href="#how-to-get-help">How to get help</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<ol>
<li>Add <code>xmlity</code> dependency to your <code>Cargo.toml</code> file:</li>
</ol>
<pre><code class="language-toml">[dependencies]
xmlity = { version = "0.1", features = ["derive"] }

# You can use any XML library you want, but the officially supported one is `quick-xml` using the `xmlity-quick-xml` crate.
xmlity-quick-xml = "0.1"
</code></pre>
<ol start="2">
<li>Define your data model:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate xmlity;
extern crate xmlity_derive;
extern crate xmlity_quick_xml;

use xmlity::{Serialize, Deserialize};;
use xmlity_derive::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
#[xelement(name = "name")]
struct Name(String);

#[derive(Serialize, Deserialize)]
#[xelement(name = "age")]
struct Age(u8);

#[derive(Serialize, Deserialize)]
#[xelement(name = "person")]
struct Person {
    name: Name,
    age: Age,
}

let person = Person {
    name: Name("John".to_string()),
    age: Age(42),
};

let xml = xmlity_quick_xml::to_string(&amp;person).expect("Failed to serialize");
assert_eq!(xml, r#"&lt;person&gt;&lt;name&gt;John&lt;/name&gt;&lt;age&gt;42&lt;/age&gt;&lt;/person&gt;"#);

let person: Person = xmlity_quick_xml::from_str(&amp;xml).expect("Failed to deserialize");
assert_eq!(person.name.0, "John");
assert_eq!(person.age.0, 42);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-data-model"><a class="header" href="#the-data-model">The data model</a></h1>
<p>The data model of Xmlity is heavily inspired by serde.</p>
<h2 id="elements"><a class="header" href="#elements">Elements</a></h2>
<p>The data-model of elements in Xmlity is built as a two-stage design, where the first stage of (de)serialization handles attributes and the second handles children. This is enforced by types so that both readers and writers can read in a logical direction, not having to jump between handling attributes and child elements.</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<h2 id="groups"><a class="header" href="#groups">Groups</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-details"><a class="header" href="#derive-details">Derive details</a></h1>
<h2 id="serializedeserialize---xelement-on-structs"><a class="header" href="#serializedeserialize---xelement-on-structs"><code>Serialize</code>/<code>Deserialize</code> - <code>#[xelement(...)]</code> on structs</a></h2>
<p>The <code>#[xelement(...)]</code> attribute can be used to serialize/deserialize a struct as an XML element.</p>
<h3 id="name---and-namespace--"><a class="header" href="#name---and-namespace--"><code>name = "..."</code> and <code>namespace = "..."</code></a></h3>
<p>If <code>name</code> is not specified, the name of the struct will be used.
These attributes can be used to require that an element has a specific name and namespace. If the namespace is not specified, it will be defaulted to the blank namespace.</p>
<h3 id="deserialize_any_name--truefalse"><a class="header" href="#deserialize_any_name--truefalse"><code>deserialize_any_name = true/false</code></a></h3>
<p>If <code>deserialize_any_name</code> is set to <code>true</code>, the element will be deserialized regardless of its name. This is useful for elements that can have multiple names, or for elements that are used in multiple contexts.</p>
<h3 id="attribute_order---and-children_order--"><a class="header" href="#attribute_order---and-children_order--"><code>attribute_order = "..."</code> and <code>children_order = "..."</code></a></h3>
<p>By default, elements in XMLity are deserialized regardless of the order of the inputs, but this can be changed using the <code>attribute_order</code> and <code>children_order</code> attributes. These attributes change elements to require that the inputs be in the same order as the fields in the struct. The possible values are as follows:</p>
<ul>
<li><code>loose</code>: Elements must be in order, but incorrect elements can be interspersed between them (if <code>allow_unknown_attributes</code>/<code>allow_unknown_children</code> is enabled).</li>
<li><code>none</code>: Elements can be in any order (default).</li>
</ul>
<!-- TODO: Some examples -->
<p>For example, the following struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO
<span class="boring">}</span></code></pre></pre>
<h3 id="preferred_prefix--"><a class="header" href="#preferred_prefix--"><code>preferred_prefix = "..."</code></a></h3>
<p>Thia field is used to specify the preferred prefix for the element. This is used when serializing the element to XML. If the element is not in the default namespace, the preferred prefix will be used. If the element is in the default namespace, the preferred prefix will be ignored.</p>
<h3 id="enforce_prefix--truefalse"><a class="header" href="#enforce_prefix--truefalse"><code>enforce_prefix = true/false</code></a></h3>
<p>This field requires <code>preferred_prefix</code> to be specified. This field encorces that the element will always use the specified prefix when serialized to XML.</p>
<h2 id="serializedeserialize---xvalue-on-enums"><a class="header" href="#serializedeserialize---xvalue-on-enums"><code>Serialize</code>/<code>Deserialize</code> - <code>#[xvalue(...)]</code> on enums</a></h2>
<p>The <code>#[xvalue(...)]</code> attribute can be used to serialize/deserialize an enum as a text value.</p>
<h3 id="rename_all--"><a class="header" href="#rename_all--"><code>rename_all = "..."</code></a></h3>
<p>This field is used to specify the format of the text value. The possible values are <code>"lowercase"</code>, <code>"UPPERCASE"</code>, <code>"PascalCase"</code>, <code>"camelCase"</code>, <code>"snake_case"</code>, <code>"SCREAMING_SNAKE_CASE"</code>, <code>"kebab-case"</code>, <code>"SCREAMING-KEBAB-CASE"</code>.</p>
<h3 id="allow_cdata--truefalse"><a class="header" href="#allow_cdata--truefalse"><code>allow_cdata = true/false</code></a></h3>
<p>Defaults to true. If true, the text value can be deserialized from a CDATA section.</p>
<h3 id="allow_text--truefalse"><a class="header" href="#allow_text--truefalse"><code>allow_text = true/false</code></a></h3>
<p>Defaults to true. If true, the text value can be deserialized from a text node.</p>
<h2 id="serializationgroupdeserializationgroup---xgroup-on-structs"><a class="header" href="#serializationgroupdeserializationgroup---xgroup-on-structs"><code>SerializationGroup</code>/<code>DeserializationGroup</code> - <code>#[xgroup(...)]</code> on structs</a></h2>
<p>The <code>SerializationGroup</code> and <code>DeserializationGroup</code> traits are used to define groups of elements that can be serialized and deserialized together. This is useful for elements that are always used together, or for elements that are part of a larger structure.</p>
<h3 id="attribute_order---and-children_order---1"><a class="header" href="#attribute_order---and-children_order---1"><code>attribute_order = "..."</code> and <code>children_order = "..."</code></a></h3>
<p>By default, groups in XMLity are deserialized regardless of the order of the inputs, but this can be changed using the <code>attribute_order</code> and <code>children_order</code> attributes. These attributes change groups to require that the inputs be in the same order as the fields in the struct. The possible values are as follows:</p>
<ul>
<li><code>strict</code>: Elements/groups must be in order, and no other elements can be interspersed between them.</li>
<li><code>loose</code>: Elements/groups must be in order, but incorrect elements can be interspersed between them. This can include elements in parent groups/elements.</li>
<li><code>none</code>: Elements/groups can be in any order (default).</li>
</ul>
<!-- TODO: Some examples -->
<p>For example, the following struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO
<span class="boring">}</span></code></pre></pre>
<p>This behaviour works on nested levels, so if you have an element with <code>children_order = "loose"</code>, and a group with <code>children_order = "none"</code> inside it, the elements listed in the group can be in any order, but they must be in order with respect to the other elements in the parent element.</p>
<!-- TODO: Some examples -->
<h2 id="serializedeserialize---nothing-on-enums"><a class="header" href="#serializedeserialize---nothing-on-enums"><code>Serialize</code>/<code>Deserialize</code> - Nothing on enums</a></h2>
<p>All variants must have exactly one unnamed field, and the type of that field must implement <code>Serialize</code>/<code>Deserialize</code>.</p>
<p>When serializing, it will try to serialize each type in order of the variants. If it succeeds, it will wrap the serialized value in the variant and return it.</p>
<p>When deserializing, it deserializes the field and then wraps it in the variant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-serialization"><a class="header" href="#custom-serialization">Custom serialization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-serialize"><a class="header" href="#implementing-serialize">Implementing <code>Serialize</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-serializeattribute"><a class="header" href="#implementing-serializeattribute">Implementing <code>SerializeAttribute</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-deserialize"><a class="header" href="#implementing-deserialize">Implementing <code>Deserialize</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-serializer-or-deserializer"><a class="header" href="#implementing-a-serializer-or-deserializer">Implementing a <code>Serializer</code> or <code>Deserializer</code></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-serializer"><a class="header" href="#implementing-a-serializer">Implementing a <code>Serializer</code></a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-deserializer"><a class="header" href="#implementing-a-deserializer">Implementing a <code>Deserializer</code></a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h1>
<p>Some features of XMLity are not enabled by default but can instead be enabled using feature flags.</p>
<h2 id="features--derive"><a class="header" href="#features--derive"><code>features = ["derive"]</code></a></h2>
<p>Enables the proc-macros covered in <a href="7_feature_flags/../3_derive_details/README.html">Derive details</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
